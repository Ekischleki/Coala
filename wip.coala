collection bool {
    sub and(bool: a, bool: b) {} = not bool::nand(a, b)
    sub nand(bool: a, bool: b) {} = or(not a, not b)
    sub nor(bool: a, bool: b) {} = not or(a, b)
    sub xor(bool: a, bool: b) {
        let not_both_true = bool::nand(a, b)
        let either_true = or(a, b)
    } = bool::and(not_both_true, either_true)
    sub xnor(bool: a, bool: b) {
        let both_true = bool::and(a, b)
        let both_false = bool::nor(a, b)
    } = or(both_true, both_false)
    sub eq(bool: a, bool: b) {} = bool::xnor(a, b)
}
collection bit {
    # Selects a if select is true, selects b otherwise
    sub select(bool: a, bool: b, bool: select) {
        let select_a = bool::and(a, select)
        let select_b = bool::and(b, not select)
    } = or (select_a, select_b)

    sub full_adder(bool: a, bool: b, bool: c) {
        let a_xor_b = bool::xor(a, b)
        let data = bool::xor(c, a_xor_b)
        let carry = or(bool::and(a, b), bool::and(c, a_xor_b))
    } = ArithmeticResult {
        carry: carry,
        data: data
    }
    sub half_adder(bool: a, bool: b) {
        let carry = bool::and(a, b)
        let data = bool::xor(a, b)
    } = ArithmeticResult {
            data: data, 
            carry: carry
        }
}
collection assert {
    sub eq(bool: a, bool: b) {
        force bool::eq(a, b) => true
    }
    sub neq(bool: a, bool: b) {
        force bool::eq(a, b) => false
    }
    sub is_true(bool: a) {
        force a => true
    }
    sub is_false(bool: a) {
        force a => false
    }
}

composite ArithmeticResult {
    bool: data,
    bool: carry
}

#Defines as super value which can only be used as a constant to expand loop macros.
super INT_LENGTH = 16

problem {

    sub test(bool: a_1, bool: a_2, bool: a_3, bool: b_1, bool: b_2, bool: b_3) {
        
        let a = [a_1, a_2, a_3]
        let b = [b_1, b_2, b_3]
        let carry = false
        let res = [false; 3]
        #output (a, b)
        let i = 0
        #output (i, a[i], b[i])
        
        for (i in 3) {
            let a_i = a[i]
            let b_i = b[i]
            let result = bit::full_adder(a_i, b_i, carry)
            #output ("i, a_i, b_i, carry, result: ", i, a_i, b_i, carry, result)

            res[i] = result.data
            carry = result.carry
        }
        output res
        output carry
        force res[0] => true
        force res[1] => false
        force res[2] => true
        force carry => false
    }

}


solution {
    # (110 + 010 = 101): 3 + 2 = 5
    test(true, true, false, false, true, false)
}


