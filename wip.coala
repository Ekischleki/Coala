collection bool {
    sub and(bool: a, bool: b) {} = not bool::nand(a, b)
    sub nand(bool: a, bool: b) {} = or(not a, not b)
    sub nor(bool: a, bool: b) {} = not or(a, b)
    sub xor(bool: a, bool: b) {
        let not_both_true = bool::nand(a, b)
        let either_true = or(a, b)
    } = bool::and(not_both_true, either_true)
    sub xnor(bool: a, bool: b) {
        let both_true = bool::and(a, b)
        let both_false = bool::nor(a, b)
    } = or(both_true, both_false)
    sub eq(bool: a, bool: b) {} = bool::xnor(a, b)
}
collection bit {
    # Selects a if select is true, selects b otherwise
    sub select(bool: a, bool: b, bool: select) {
        let select_a = bool::and(a, select)
        let select_b = bool::and(b, not select)
    } = or (select_a, select_b)

    sub full_adder(bool: a, bool: b, bool: c) {
        let a_xor_b = bool::xor(a, b)
        let data = bool::xor(c, a_xor_b)
        let carry = or(bool::and(a, b), bool::and(c, a_xor_b))
    } = ArithmeticResult {
        carry: carry,
        data: data
    }
    sub half_adder(bool: a, bool: b) {
        let carry = bool::and(a, b)
        let data = bool::xor(a, b)
    } = ArithmeticResult {
            data: data, 
            carry: carry
        }
}
collection int {
    # Since the data array is from least significant bit to most significant bit, left shifting is actually right shifting, but we will call it left shifting for convenience.
    # Left shift resize

    sub resize(int: a, sup: size) {
        let res = int::zero(size)
        for (i in super::min(a.int_length, size)) {
            res.data[i] = a.data[i]
        }
    } = res

    sub lfsr(int: a, bool: fill_bit) {
        let res = int::zero(super::add(a.int_length, 1))
        res.data[0] = fill_bit
        for (i in a.int_length) {
            res.data[super::add(i, 1)] = a.data[i]
        }
    } = res

    # Left shift
    sub lfs(int: a, bool: fill_bit) {
        let res = int::zero(a.int_length)
        res.data[0] = fill_bit
        for (i in super::sb(a.int_length, 1)) {
            res.data[super::add(i, 1)] = a.data[i]
        }
    } = res
    sub from_array(array: data) {
        let int_length = super::len(data)
    } = Int {
        data: data,
        int_length: int_length
    }
    sub add_if_true(int: a, int: b, bool: condition) {
        if (not condition) {
            for (i in b.int_length) {
                b.data[i] = false
            }
        }

    } = int::add(a, b)

    sub zero(sup: int_length) {
        let data = [false; int_length]
    } = Int {
        data: data,
        int_length: int_length
    }

    sub from_super(sup: int, sup: int_length) {
        let data = [false; int_length]
        let i = 0
        for (i in int_length) {
            if (super::eq(super::mod(int, 2), 1)) {
                data[i] = true
            }
            int = super::div(int, 2)
        }
    } = Int {
        data: data,
        int_length: int_length
    }

    sub mul(int: a, int: b) {
        let res_size = super::add(a.int_length, b.int_length)
        let cur = int::resize(a, res_size)
        let res = int::zero(res_size)
        for(i in b.int_length) {
            let res = int::add_if_true(res, cur, b.data[i])

            let cur = int::lfs(cur, false)
        }
    } = res

    sub add(Int: a, Int: b) {
        if (not super::eq(a.int_length, b.int_length)) {
            output "Error: Ints must be of the same length to add"
            force false => true
        }

        let carry = false
        let data = [false; a.int_length]
        for (i in a.int_length) {
            let a_i = a.data[i]
            let b_i = b.data[i]
            let res = bit::full_adder(a_i, b_i, carry)
            data[i] = res.data
            carry = res.carry
        }
    } = Int {
        data: data,
        int_length: a.int_length
    }

    sub eq(Int: a, Int: b) {
        if (not super::eq(a.int_length, b.int_length)) {
            output "Error: Ints must be of the same length to add"
            force false => true
        }

        let eq = true
        for (i in a.int_length) {
            let a_i = a.data[i]
            let b_i = b.data[i]
            if (not bool::eq(a_i, b_i)) {
                eq = false
            }
        }
    } = eq
    

}

composite Int {
    array: data,
    super_i: int_length
}
collection assert {
    sub eq(bool: a, bool: b) {
        force bool::eq(a, b) => true
    }
    sub neq(bool: a, bool: b) {
        force bool::eq(a, b) => false
    }
    sub is_true(bool: a) {
        force a => true
    }
    sub is_false(bool: a) {
        force a => false
    }
}

composite ArithmeticResult {
    bool: data,
    bool: carry
}

#Defines as super value which can only be used as a constant to expand loop macros.
super INT_LENGTH = 16

problem {

    sub test(
    bool: a_0, bool: a_1, bool: a_2, bool: a_3,
    bool: a_4, bool: a_5, bool: a_6, bool: a_7, 
    bool: b_0, bool: b_1, bool: b_2, bool: b_3, 
    bool: b_4, bool: b_5, bool: b_6, bool: b_7) {
        let a = int::from_array([
            a_0, a_1, a_2, a_3,
            a_4, #a_5, a_6, a_7
        ])
        let b = int::from_array([
            b_0, b_1, b_2, b_3,
            b_4, #b_5, b_6, b_7
        ])
        let c = int::mul(a, b)

        let res = int::from_super(69, 10)
        output ("a * b = c =? res", a, b, c, res)
        force int::eq(c, res) => true
    }

}


solution {
    
    test(true, true, true, false,
        true, false, false, false,
        true, true, false, false,
        false, false, false, false)
}


